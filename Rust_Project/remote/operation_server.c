/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "cd.h"
#include "filecount.h"
#include "getdir.h"
#include "ls.h"
#include "operation.h"

FILE *remote_file;

char **
getdir_1_svc(void *argp, struct svc_req *rqstp)
{
	printf("client called 'getdir'\n");
	static char *result;
	result = getdir();
	return &result;
}

bool_t *
changedir_1_svc(char **argp, struct svc_req *rqstp)
{
	printf("client called 'cd %s'\n", *argp);
	static bool_t result;
	result = changedir(*argp);
	return &result;
}

int *filecount_1_svc(char **argp, struct svc_req *rqstp)
{
	printf("client called 'filecount'\n");
	static int result;
	result = filecount(*argp);
	return &result;
}

bool_t *
openlist_1_svc(char **argp, struct svc_req *rqstp)
{
	printf("client called 'openlist %s'\n", *argp);
	static bool_t result;
	result = openlist(*argp);
	return &result;
}

struct DIRENTRY_T *
nextlist_1_svc(char **argp, struct svc_req *rqstp)
{
	printf("client called 'nextlist'\n");
	static struct DIRENTRY_T result;
	if (nextlist(*argp))
	{
		result.name = entry.name;
		result.isDirectory = entry.isDirectory;
		result.size = entry.size;
		result.lastModified = entry.lastModified;
		result.filtered = entry.filtered;
	}
	else
	{
		// return NULL does not break the loop
		result.name = NULL;
	}
	return &result;
}

bool_t *
closelist_1_svc(void *argp, struct svc_req *rqstp)
{
	printf("client called 'closelist'\n");
	static bool_t result;
	result = closelist();
	return &result;
}

bool_t *
openfiletowrite_1_svc(char **argp, struct svc_req *rqstp)
{
	printf("client called 'openfiletowrite'.\n");
	static bool_t result;
	result = TRUE;
	remote_file = fopen(*argp, "w");
	if (remote_file == NULL)
	{
		result = FALSE;
	}
	return &result;
}

bool_t *
put_nextwrite_1_svc(struct BLOCK_T *argp, struct svc_req *rqstp)
{
	/*receive block from local,
	if do not get all the local file,
	retuen false */
	printf("client called nextwrite.\n");
	static bool_t result;
	result = TRUE;
	fwrite(argp->data.data_val, sizeof(char), argp->data.data_len, remote_file);
	if (argp->data.data_len == 512)
	{
		result = FALSE;
	}
	return &result;
}

bool_t *
put_closefile_1_svc(void *argp, struct svc_req *rqstp)
{
	printf("client called closefile.\n");
	static bool_t result;
	result = TRUE;
	int i;
	i = fclose(remote_file);
	if (i != 0)
	{
		result = FALSE;
	}
	return &result;
}

bool_t *
get_openfiletoread_1_svc(char **argp, struct svc_req *rqstp)
{
	printf("client called get_openfiletoread.\n");
	static bool_t result;
	result = TRUE;
	remote_file = fopen(*argp, "r+");
	if (remote_file == NULL)
	{
		result = FALSE;
	}
	return &result;
}

struct BLOCK_T *
get_nextread_1_svc(void *argp, struct svc_req *rqstp)
{
	/*get the remote file name then open it,
	then fill the block,
	and pass it to client if it is up to 512 byte or eof.*/
	printf("client called get_nextread.\n");
	static struct BLOCK_T result;

	result.data.data_len = 0;
	static char temp_str[MAX_BLOCK_SIZE + 1];
	result.data.data_val = temp_str;
	memset(temp_str, 0, sizeof(temp_str));
	u_int count = 0;
	/* while ((count < MAX_BLOCK_SIZE) )
	{
		if ((temp_ch=fgetc(remote_file))==EOF)
		{
			break;
		}
		temp_str[count] =temp_ch;		
		count++;			
	}
	result.data.data_len=count;*/
	count = fread(temp_str, 1, MAX_BLOCK_SIZE, remote_file);
	printf("count=%d\ndata=%c...", count, temp_str[0]);
	result.data.data_len = count;
	return &result;
}

bool_t *
get_closefile_1_svc(void *argp, struct svc_req *rqstp)
{
	printf("client called closefile.\n");
	static bool_t result;
	result = TRUE;
	int i;
	i = fclose(remote_file);
	if (i != 0)
	{
		result = FALSE;
	}
	return &result;
}

bool_t *
rand_openfiletoread_1_svc(char **argp, struct svc_req *rqstp)
{
	printf("client called openfiletoread.\n");
	static bool_t result;
	result = TRUE;
	remote_file = fopen(*argp, "r");
	if (remote_file == NULL)
	{
		result = FALSE;
	}
	return &result;
}

bool_t *
rand_closefile_1_svc(void *argp, struct svc_req *rqstp)
{
	printf("client called closefile.\n");
	static bool_t result;
	int i;
	result = TRUE;
	i = fclose(remote_file);
	if (i != 0)
	{
		result = FALSE;
	}
	return &result;
}

struct BLOCK_T *
rand_nextread_1_svc(struct RANDOMINFO_T *argp, struct svc_req *rqstp)
{
	printf("client called rand_nextread.\n");
	static struct BLOCK_T result;
	static char temp_str[MAX_BLOCK_SIZE + 1];
	memset(temp_str, 0, sizeof(temp_str));
	result.data.data_val = temp_str;
	u_int count = 0;
	char temp_ch;
	int firstbyte = argp->firstbyte;
	int bytenum = argp->bytenum;
	int i, j, k;
	j = firstbyte / MAX_BLOCK_SIZE;
	k = firstbyte % MAX_BLOCK_SIZE;

	for (i = 0; i < j; ++i)
	{
		count = fread(temp_str, sizeof(char), MAX_BLOCK_SIZE, remote_file);
		count = 0;
		memset(temp_str, 0, sizeof(temp_str));
	}

	count = fread(temp_str, sizeof(char), k, remote_file);
	count = 0;
	memset(temp_str, 0, sizeof(temp_str));

	count = fread(temp_str, sizeof(char), bytenum, remote_file);
	result.data.data_len = count;
	return &result;
}
