// This file is generated by rust-protobuf 2.10.2. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `yadfs.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_10_2;

#[derive(PartialEq,Clone,Default)]
pub struct HelloRequest {
    // message fields
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HelloRequest {
    fn default() -> &'a HelloRequest {
        <HelloRequest as ::protobuf::Message>::default_instance()
    }
}

impl HelloRequest {
    pub fn new() -> HelloRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for HelloRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HelloRequest {
        HelloRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &HelloRequest| { &m.name },
                    |m: &mut HelloRequest| { &mut m.name },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<HelloRequest>(
                    "HelloRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static HelloRequest {
        static mut instance: ::protobuf::lazy::Lazy<HelloRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const HelloRequest,
        };
        unsafe {
            instance.get(HelloRequest::new)
        }
    }
}

impl ::protobuf::Clear for HelloRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HelloRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HelloRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HelloResponse {
    // message fields
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HelloResponse {
    fn default() -> &'a HelloResponse {
        <HelloResponse as ::protobuf::Message>::default_instance()
    }
}

impl HelloResponse {
    pub fn new() -> HelloResponse {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for HelloResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HelloResponse {
        HelloResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &HelloResponse| { &m.name },
                    |m: &mut HelloResponse| { &mut m.name },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<HelloResponse>(
                    "HelloResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static HelloResponse {
        static mut instance: ::protobuf::lazy::Lazy<HelloResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const HelloResponse,
        };
        unsafe {
            instance.get(HelloResponse::new)
        }
    }
}

impl ::protobuf::Clear for HelloResponse {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HelloResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HelloResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetDirRequest {
    // message fields
    pub file_path: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetDirRequest {
    fn default() -> &'a GetDirRequest {
        <GetDirRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetDirRequest {
    pub fn new() -> GetDirRequest {
        ::std::default::Default::default()
    }

    // string file_path = 1;


    pub fn get_file_path(&self) -> &str {
        &self.file_path
    }
    pub fn clear_file_path(&mut self) {
        self.file_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_file_path(&mut self, v: ::std::string::String) {
        self.file_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_path(&mut self) -> &mut ::std::string::String {
        &mut self.file_path
    }

    // Take field
    pub fn take_file_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.file_path, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetDirRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.file_path)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.file_path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.file_path);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.file_path.is_empty() {
            os.write_string(1, &self.file_path)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetDirRequest {
        GetDirRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "file_path",
                    |m: &GetDirRequest| { &m.file_path },
                    |m: &mut GetDirRequest| { &mut m.file_path },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetDirRequest>(
                    "GetDirRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetDirRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetDirRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetDirRequest,
        };
        unsafe {
            instance.get(GetDirRequest::new)
        }
    }
}

impl ::protobuf::Clear for GetDirRequest {
    fn clear(&mut self) {
        self.file_path.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetDirRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetDirRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetDirResponse {
    // message fields
    pub current_dir: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetDirResponse {
    fn default() -> &'a GetDirResponse {
        <GetDirResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetDirResponse {
    pub fn new() -> GetDirResponse {
        ::std::default::Default::default()
    }

    // string current_dir = 1;


    pub fn get_current_dir(&self) -> &str {
        &self.current_dir
    }
    pub fn clear_current_dir(&mut self) {
        self.current_dir.clear();
    }

    // Param is passed by value, moved
    pub fn set_current_dir(&mut self, v: ::std::string::String) {
        self.current_dir = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_current_dir(&mut self) -> &mut ::std::string::String {
        &mut self.current_dir
    }

    // Take field
    pub fn take_current_dir(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.current_dir, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetDirResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.current_dir)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.current_dir.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.current_dir);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.current_dir.is_empty() {
            os.write_string(1, &self.current_dir)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetDirResponse {
        GetDirResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "current_dir",
                    |m: &GetDirResponse| { &m.current_dir },
                    |m: &mut GetDirResponse| { &mut m.current_dir },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetDirResponse>(
                    "GetDirResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetDirResponse {
        static mut instance: ::protobuf::lazy::Lazy<GetDirResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetDirResponse,
        };
        unsafe {
            instance.get(GetDirResponse::new)
        }
    }
}

impl ::protobuf::Clear for GetDirResponse {
    fn clear(&mut self) {
        self.current_dir.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetDirResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetDirResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChangeDirRequest {
    // message fields
    pub dir_path: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChangeDirRequest {
    fn default() -> &'a ChangeDirRequest {
        <ChangeDirRequest as ::protobuf::Message>::default_instance()
    }
}

impl ChangeDirRequest {
    pub fn new() -> ChangeDirRequest {
        ::std::default::Default::default()
    }

    // string dir_path = 1;


    pub fn get_dir_path(&self) -> &str {
        &self.dir_path
    }
    pub fn clear_dir_path(&mut self) {
        self.dir_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_dir_path(&mut self, v: ::std::string::String) {
        self.dir_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dir_path(&mut self) -> &mut ::std::string::String {
        &mut self.dir_path
    }

    // Take field
    pub fn take_dir_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.dir_path, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ChangeDirRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.dir_path)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.dir_path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.dir_path);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.dir_path.is_empty() {
            os.write_string(1, &self.dir_path)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChangeDirRequest {
        ChangeDirRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "dir_path",
                    |m: &ChangeDirRequest| { &m.dir_path },
                    |m: &mut ChangeDirRequest| { &mut m.dir_path },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ChangeDirRequest>(
                    "ChangeDirRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ChangeDirRequest {
        static mut instance: ::protobuf::lazy::Lazy<ChangeDirRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ChangeDirRequest,
        };
        unsafe {
            instance.get(ChangeDirRequest::new)
        }
    }
}

impl ::protobuf::Clear for ChangeDirRequest {
    fn clear(&mut self) {
        self.dir_path.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChangeDirRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChangeDirRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChangeDirResponse {
    // message fields
    pub is_success: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChangeDirResponse {
    fn default() -> &'a ChangeDirResponse {
        <ChangeDirResponse as ::protobuf::Message>::default_instance()
    }
}

impl ChangeDirResponse {
    pub fn new() -> ChangeDirResponse {
        ::std::default::Default::default()
    }

    // int32 is_success = 1;


    pub fn get_is_success(&self) -> i32 {
        self.is_success
    }
    pub fn clear_is_success(&mut self) {
        self.is_success = 0;
    }

    // Param is passed by value, moved
    pub fn set_is_success(&mut self, v: i32) {
        self.is_success = v;
    }
}

impl ::protobuf::Message for ChangeDirResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.is_success = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.is_success != 0 {
            my_size += ::protobuf::rt::value_size(1, self.is_success, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.is_success != 0 {
            os.write_int32(1, self.is_success)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChangeDirResponse {
        ChangeDirResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "is_success",
                    |m: &ChangeDirResponse| { &m.is_success },
                    |m: &mut ChangeDirResponse| { &mut m.is_success },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ChangeDirResponse>(
                    "ChangeDirResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ChangeDirResponse {
        static mut instance: ::protobuf::lazy::Lazy<ChangeDirResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ChangeDirResponse,
        };
        unsafe {
            instance.get(ChangeDirResponse::new)
        }
    }
}

impl ::protobuf::Clear for ChangeDirResponse {
    fn clear(&mut self) {
        self.is_success = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChangeDirResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChangeDirResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FileCountRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FileCountRequest {
    fn default() -> &'a FileCountRequest {
        <FileCountRequest as ::protobuf::Message>::default_instance()
    }
}

impl FileCountRequest {
    pub fn new() -> FileCountRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for FileCountRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FileCountRequest {
        FileCountRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<FileCountRequest>(
                    "FileCountRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FileCountRequest {
        static mut instance: ::protobuf::lazy::Lazy<FileCountRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FileCountRequest,
        };
        unsafe {
            instance.get(FileCountRequest::new)
        }
    }
}

impl ::protobuf::Clear for FileCountRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FileCountRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FileCountRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FileCountResponse {
    // message fields
    pub file_count: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FileCountResponse {
    fn default() -> &'a FileCountResponse {
        <FileCountResponse as ::protobuf::Message>::default_instance()
    }
}

impl FileCountResponse {
    pub fn new() -> FileCountResponse {
        ::std::default::Default::default()
    }

    // int32 file_count = 1;


    pub fn get_file_count(&self) -> i32 {
        self.file_count
    }
    pub fn clear_file_count(&mut self) {
        self.file_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_file_count(&mut self, v: i32) {
        self.file_count = v;
    }
}

impl ::protobuf::Message for FileCountResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.file_count = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.file_count != 0 {
            my_size += ::protobuf::rt::value_size(1, self.file_count, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.file_count != 0 {
            os.write_int32(1, self.file_count)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FileCountResponse {
        FileCountResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "file_count",
                    |m: &FileCountResponse| { &m.file_count },
                    |m: &mut FileCountResponse| { &mut m.file_count },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FileCountResponse>(
                    "FileCountResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FileCountResponse {
        static mut instance: ::protobuf::lazy::Lazy<FileCountResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FileCountResponse,
        };
        unsafe {
            instance.get(FileCountResponse::new)
        }
    }
}

impl ::protobuf::Clear for FileCountResponse {
    fn clear(&mut self) {
        self.file_count = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FileCountResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FileCountResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListRequest {
    fn default() -> &'a ListRequest {
        <ListRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListRequest {
    pub fn new() -> ListRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ListRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListRequest {
        ListRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<ListRequest>(
                    "ListRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListRequest {
        static mut instance: ::protobuf::lazy::Lazy<ListRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListRequest,
        };
        unsafe {
            instance.get(ListRequest::new)
        }
    }
}

impl ::protobuf::Clear for ListRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListResponse {
    // message fields
    pub list_dir: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListResponse {
    fn default() -> &'a ListResponse {
        <ListResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListResponse {
    pub fn new() -> ListResponse {
        ::std::default::Default::default()
    }

    // string list_dir = 1;


    pub fn get_list_dir(&self) -> &str {
        &self.list_dir
    }
    pub fn clear_list_dir(&mut self) {
        self.list_dir.clear();
    }

    // Param is passed by value, moved
    pub fn set_list_dir(&mut self, v: ::std::string::String) {
        self.list_dir = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_list_dir(&mut self) -> &mut ::std::string::String {
        &mut self.list_dir
    }

    // Take field
    pub fn take_list_dir(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.list_dir, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.list_dir)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.list_dir.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.list_dir);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.list_dir.is_empty() {
            os.write_string(1, &self.list_dir)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListResponse {
        ListResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "list_dir",
                    |m: &ListResponse| { &m.list_dir },
                    |m: &mut ListResponse| { &mut m.list_dir },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListResponse>(
                    "ListResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListResponse {
        static mut instance: ::protobuf::lazy::Lazy<ListResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListResponse,
        };
        unsafe {
            instance.get(ListResponse::new)
        }
    }
}

impl ::protobuf::Clear for ListResponse {
    fn clear(&mut self) {
        self.list_dir.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OpenFiletoReadRequest {
    // message fields
    pub file_path: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OpenFiletoReadRequest {
    fn default() -> &'a OpenFiletoReadRequest {
        <OpenFiletoReadRequest as ::protobuf::Message>::default_instance()
    }
}

impl OpenFiletoReadRequest {
    pub fn new() -> OpenFiletoReadRequest {
        ::std::default::Default::default()
    }

    // string file_path = 1;


    pub fn get_file_path(&self) -> &str {
        &self.file_path
    }
    pub fn clear_file_path(&mut self) {
        self.file_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_file_path(&mut self, v: ::std::string::String) {
        self.file_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_path(&mut self) -> &mut ::std::string::String {
        &mut self.file_path
    }

    // Take field
    pub fn take_file_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.file_path, ::std::string::String::new())
    }
}

impl ::protobuf::Message for OpenFiletoReadRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.file_path)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.file_path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.file_path);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.file_path.is_empty() {
            os.write_string(1, &self.file_path)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OpenFiletoReadRequest {
        OpenFiletoReadRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "file_path",
                    |m: &OpenFiletoReadRequest| { &m.file_path },
                    |m: &mut OpenFiletoReadRequest| { &mut m.file_path },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<OpenFiletoReadRequest>(
                    "OpenFiletoReadRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static OpenFiletoReadRequest {
        static mut instance: ::protobuf::lazy::Lazy<OpenFiletoReadRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const OpenFiletoReadRequest,
        };
        unsafe {
            instance.get(OpenFiletoReadRequest::new)
        }
    }
}

impl ::protobuf::Clear for OpenFiletoReadRequest {
    fn clear(&mut self) {
        self.file_path.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OpenFiletoReadRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OpenFiletoReadRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OpenFiletoReadResponse {
    // message fields
    pub is_success: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OpenFiletoReadResponse {
    fn default() -> &'a OpenFiletoReadResponse {
        <OpenFiletoReadResponse as ::protobuf::Message>::default_instance()
    }
}

impl OpenFiletoReadResponse {
    pub fn new() -> OpenFiletoReadResponse {
        ::std::default::Default::default()
    }

    // int32 is_success = 1;


    pub fn get_is_success(&self) -> i32 {
        self.is_success
    }
    pub fn clear_is_success(&mut self) {
        self.is_success = 0;
    }

    // Param is passed by value, moved
    pub fn set_is_success(&mut self, v: i32) {
        self.is_success = v;
    }
}

impl ::protobuf::Message for OpenFiletoReadResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.is_success = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.is_success != 0 {
            my_size += ::protobuf::rt::value_size(1, self.is_success, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.is_success != 0 {
            os.write_int32(1, self.is_success)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OpenFiletoReadResponse {
        OpenFiletoReadResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "is_success",
                    |m: &OpenFiletoReadResponse| { &m.is_success },
                    |m: &mut OpenFiletoReadResponse| { &mut m.is_success },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<OpenFiletoReadResponse>(
                    "OpenFiletoReadResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static OpenFiletoReadResponse {
        static mut instance: ::protobuf::lazy::Lazy<OpenFiletoReadResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const OpenFiletoReadResponse,
        };
        unsafe {
            instance.get(OpenFiletoReadResponse::new)
        }
    }
}

impl ::protobuf::Clear for OpenFiletoReadResponse {
    fn clear(&mut self) {
        self.is_success = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OpenFiletoReadResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OpenFiletoReadResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NextReadRequest {
    // message fields
    pub file_name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NextReadRequest {
    fn default() -> &'a NextReadRequest {
        <NextReadRequest as ::protobuf::Message>::default_instance()
    }
}

impl NextReadRequest {
    pub fn new() -> NextReadRequest {
        ::std::default::Default::default()
    }

    // string file_name = 1;


    pub fn get_file_name(&self) -> &str {
        &self.file_name
    }
    pub fn clear_file_name(&mut self) {
        self.file_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_file_name(&mut self, v: ::std::string::String) {
        self.file_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_name(&mut self) -> &mut ::std::string::String {
        &mut self.file_name
    }

    // Take field
    pub fn take_file_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.file_name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for NextReadRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.file_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.file_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.file_name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.file_name.is_empty() {
            os.write_string(1, &self.file_name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NextReadRequest {
        NextReadRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "file_name",
                    |m: &NextReadRequest| { &m.file_name },
                    |m: &mut NextReadRequest| { &mut m.file_name },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NextReadRequest>(
                    "NextReadRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NextReadRequest {
        static mut instance: ::protobuf::lazy::Lazy<NextReadRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NextReadRequest,
        };
        unsafe {
            instance.get(NextReadRequest::new)
        }
    }
}

impl ::protobuf::Clear for NextReadRequest {
    fn clear(&mut self) {
        self.file_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NextReadRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NextReadRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NextReadResponse {
    // message fields
    pub file_name: ::std::string::String,
    pub block: ::std::string::String,
    pub is_end: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NextReadResponse {
    fn default() -> &'a NextReadResponse {
        <NextReadResponse as ::protobuf::Message>::default_instance()
    }
}

impl NextReadResponse {
    pub fn new() -> NextReadResponse {
        ::std::default::Default::default()
    }

    // string file_name = 1;


    pub fn get_file_name(&self) -> &str {
        &self.file_name
    }
    pub fn clear_file_name(&mut self) {
        self.file_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_file_name(&mut self, v: ::std::string::String) {
        self.file_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_name(&mut self) -> &mut ::std::string::String {
        &mut self.file_name
    }

    // Take field
    pub fn take_file_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.file_name, ::std::string::String::new())
    }

    // string block = 2;


    pub fn get_block(&self) -> &str {
        &self.block
    }
    pub fn clear_block(&mut self) {
        self.block.clear();
    }

    // Param is passed by value, moved
    pub fn set_block(&mut self, v: ::std::string::String) {
        self.block = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_block(&mut self) -> &mut ::std::string::String {
        &mut self.block
    }

    // Take field
    pub fn take_block(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.block, ::std::string::String::new())
    }

    // int32 is_end = 3;


    pub fn get_is_end(&self) -> i32 {
        self.is_end
    }
    pub fn clear_is_end(&mut self) {
        self.is_end = 0;
    }

    // Param is passed by value, moved
    pub fn set_is_end(&mut self, v: i32) {
        self.is_end = v;
    }
}

impl ::protobuf::Message for NextReadResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.file_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.block)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.is_end = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.file_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.file_name);
        }
        if !self.block.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.block);
        }
        if self.is_end != 0 {
            my_size += ::protobuf::rt::value_size(3, self.is_end, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.file_name.is_empty() {
            os.write_string(1, &self.file_name)?;
        }
        if !self.block.is_empty() {
            os.write_string(2, &self.block)?;
        }
        if self.is_end != 0 {
            os.write_int32(3, self.is_end)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NextReadResponse {
        NextReadResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "file_name",
                    |m: &NextReadResponse| { &m.file_name },
                    |m: &mut NextReadResponse| { &mut m.file_name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "block",
                    |m: &NextReadResponse| { &m.block },
                    |m: &mut NextReadResponse| { &mut m.block },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "is_end",
                    |m: &NextReadResponse| { &m.is_end },
                    |m: &mut NextReadResponse| { &mut m.is_end },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NextReadResponse>(
                    "NextReadResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NextReadResponse {
        static mut instance: ::protobuf::lazy::Lazy<NextReadResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NextReadResponse,
        };
        unsafe {
            instance.get(NextReadResponse::new)
        }
    }
}

impl ::protobuf::Clear for NextReadResponse {
    fn clear(&mut self) {
        self.file_name.clear();
        self.block.clear();
        self.is_end = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NextReadResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NextReadResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CloseFileRequest {
    // message fields
    pub file_path: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CloseFileRequest {
    fn default() -> &'a CloseFileRequest {
        <CloseFileRequest as ::protobuf::Message>::default_instance()
    }
}

impl CloseFileRequest {
    pub fn new() -> CloseFileRequest {
        ::std::default::Default::default()
    }

    // string file_path = 1;


    pub fn get_file_path(&self) -> &str {
        &self.file_path
    }
    pub fn clear_file_path(&mut self) {
        self.file_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_file_path(&mut self, v: ::std::string::String) {
        self.file_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_path(&mut self) -> &mut ::std::string::String {
        &mut self.file_path
    }

    // Take field
    pub fn take_file_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.file_path, ::std::string::String::new())
    }
}

impl ::protobuf::Message for CloseFileRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.file_path)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.file_path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.file_path);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.file_path.is_empty() {
            os.write_string(1, &self.file_path)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CloseFileRequest {
        CloseFileRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "file_path",
                    |m: &CloseFileRequest| { &m.file_path },
                    |m: &mut CloseFileRequest| { &mut m.file_path },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CloseFileRequest>(
                    "CloseFileRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CloseFileRequest {
        static mut instance: ::protobuf::lazy::Lazy<CloseFileRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CloseFileRequest,
        };
        unsafe {
            instance.get(CloseFileRequest::new)
        }
    }
}

impl ::protobuf::Clear for CloseFileRequest {
    fn clear(&mut self) {
        self.file_path.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CloseFileRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CloseFileRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CloseFileResponse {
    // message fields
    pub is_success: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CloseFileResponse {
    fn default() -> &'a CloseFileResponse {
        <CloseFileResponse as ::protobuf::Message>::default_instance()
    }
}

impl CloseFileResponse {
    pub fn new() -> CloseFileResponse {
        ::std::default::Default::default()
    }

    // int32 is_success = 1;


    pub fn get_is_success(&self) -> i32 {
        self.is_success
    }
    pub fn clear_is_success(&mut self) {
        self.is_success = 0;
    }

    // Param is passed by value, moved
    pub fn set_is_success(&mut self, v: i32) {
        self.is_success = v;
    }
}

impl ::protobuf::Message for CloseFileResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.is_success = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.is_success != 0 {
            my_size += ::protobuf::rt::value_size(1, self.is_success, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.is_success != 0 {
            os.write_int32(1, self.is_success)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CloseFileResponse {
        CloseFileResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "is_success",
                    |m: &CloseFileResponse| { &m.is_success },
                    |m: &mut CloseFileResponse| { &mut m.is_success },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CloseFileResponse>(
                    "CloseFileResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CloseFileResponse {
        static mut instance: ::protobuf::lazy::Lazy<CloseFileResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CloseFileResponse,
        };
        unsafe {
            instance.get(CloseFileResponse::new)
        }
    }
}

impl ::protobuf::Clear for CloseFileResponse {
    fn clear(&mut self) {
        self.is_success = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CloseFileResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CloseFileResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OpenFiletoWriteRequest {
    // message fields
    pub file_path: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OpenFiletoWriteRequest {
    fn default() -> &'a OpenFiletoWriteRequest {
        <OpenFiletoWriteRequest as ::protobuf::Message>::default_instance()
    }
}

impl OpenFiletoWriteRequest {
    pub fn new() -> OpenFiletoWriteRequest {
        ::std::default::Default::default()
    }

    // string file_path = 1;


    pub fn get_file_path(&self) -> &str {
        &self.file_path
    }
    pub fn clear_file_path(&mut self) {
        self.file_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_file_path(&mut self, v: ::std::string::String) {
        self.file_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_path(&mut self) -> &mut ::std::string::String {
        &mut self.file_path
    }

    // Take field
    pub fn take_file_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.file_path, ::std::string::String::new())
    }
}

impl ::protobuf::Message for OpenFiletoWriteRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.file_path)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.file_path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.file_path);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.file_path.is_empty() {
            os.write_string(1, &self.file_path)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OpenFiletoWriteRequest {
        OpenFiletoWriteRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "file_path",
                    |m: &OpenFiletoWriteRequest| { &m.file_path },
                    |m: &mut OpenFiletoWriteRequest| { &mut m.file_path },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<OpenFiletoWriteRequest>(
                    "OpenFiletoWriteRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static OpenFiletoWriteRequest {
        static mut instance: ::protobuf::lazy::Lazy<OpenFiletoWriteRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const OpenFiletoWriteRequest,
        };
        unsafe {
            instance.get(OpenFiletoWriteRequest::new)
        }
    }
}

impl ::protobuf::Clear for OpenFiletoWriteRequest {
    fn clear(&mut self) {
        self.file_path.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OpenFiletoWriteRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OpenFiletoWriteRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OpenFiletoWriteResopnse {
    // message fields
    pub is_success: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OpenFiletoWriteResopnse {
    fn default() -> &'a OpenFiletoWriteResopnse {
        <OpenFiletoWriteResopnse as ::protobuf::Message>::default_instance()
    }
}

impl OpenFiletoWriteResopnse {
    pub fn new() -> OpenFiletoWriteResopnse {
        ::std::default::Default::default()
    }

    // int32 is_success = 1;


    pub fn get_is_success(&self) -> i32 {
        self.is_success
    }
    pub fn clear_is_success(&mut self) {
        self.is_success = 0;
    }

    // Param is passed by value, moved
    pub fn set_is_success(&mut self, v: i32) {
        self.is_success = v;
    }
}

impl ::protobuf::Message for OpenFiletoWriteResopnse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.is_success = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.is_success != 0 {
            my_size += ::protobuf::rt::value_size(1, self.is_success, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.is_success != 0 {
            os.write_int32(1, self.is_success)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OpenFiletoWriteResopnse {
        OpenFiletoWriteResopnse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "is_success",
                    |m: &OpenFiletoWriteResopnse| { &m.is_success },
                    |m: &mut OpenFiletoWriteResopnse| { &mut m.is_success },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<OpenFiletoWriteResopnse>(
                    "OpenFiletoWriteResopnse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static OpenFiletoWriteResopnse {
        static mut instance: ::protobuf::lazy::Lazy<OpenFiletoWriteResopnse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const OpenFiletoWriteResopnse,
        };
        unsafe {
            instance.get(OpenFiletoWriteResopnse::new)
        }
    }
}

impl ::protobuf::Clear for OpenFiletoWriteResopnse {
    fn clear(&mut self) {
        self.is_success = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OpenFiletoWriteResopnse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OpenFiletoWriteResopnse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NextWriteRequest {
    // message fields
    pub file_name: ::std::string::String,
    pub block: ::std::string::String,
    pub is_end: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NextWriteRequest {
    fn default() -> &'a NextWriteRequest {
        <NextWriteRequest as ::protobuf::Message>::default_instance()
    }
}

impl NextWriteRequest {
    pub fn new() -> NextWriteRequest {
        ::std::default::Default::default()
    }

    // string file_name = 1;


    pub fn get_file_name(&self) -> &str {
        &self.file_name
    }
    pub fn clear_file_name(&mut self) {
        self.file_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_file_name(&mut self, v: ::std::string::String) {
        self.file_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_name(&mut self) -> &mut ::std::string::String {
        &mut self.file_name
    }

    // Take field
    pub fn take_file_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.file_name, ::std::string::String::new())
    }

    // string block = 2;


    pub fn get_block(&self) -> &str {
        &self.block
    }
    pub fn clear_block(&mut self) {
        self.block.clear();
    }

    // Param is passed by value, moved
    pub fn set_block(&mut self, v: ::std::string::String) {
        self.block = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_block(&mut self) -> &mut ::std::string::String {
        &mut self.block
    }

    // Take field
    pub fn take_block(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.block, ::std::string::String::new())
    }

    // int32 is_end = 3;


    pub fn get_is_end(&self) -> i32 {
        self.is_end
    }
    pub fn clear_is_end(&mut self) {
        self.is_end = 0;
    }

    // Param is passed by value, moved
    pub fn set_is_end(&mut self, v: i32) {
        self.is_end = v;
    }
}

impl ::protobuf::Message for NextWriteRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.file_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.block)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.is_end = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.file_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.file_name);
        }
        if !self.block.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.block);
        }
        if self.is_end != 0 {
            my_size += ::protobuf::rt::value_size(3, self.is_end, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.file_name.is_empty() {
            os.write_string(1, &self.file_name)?;
        }
        if !self.block.is_empty() {
            os.write_string(2, &self.block)?;
        }
        if self.is_end != 0 {
            os.write_int32(3, self.is_end)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NextWriteRequest {
        NextWriteRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "file_name",
                    |m: &NextWriteRequest| { &m.file_name },
                    |m: &mut NextWriteRequest| { &mut m.file_name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "block",
                    |m: &NextWriteRequest| { &m.block },
                    |m: &mut NextWriteRequest| { &mut m.block },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "is_end",
                    |m: &NextWriteRequest| { &m.is_end },
                    |m: &mut NextWriteRequest| { &mut m.is_end },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NextWriteRequest>(
                    "NextWriteRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NextWriteRequest {
        static mut instance: ::protobuf::lazy::Lazy<NextWriteRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NextWriteRequest,
        };
        unsafe {
            instance.get(NextWriteRequest::new)
        }
    }
}

impl ::protobuf::Clear for NextWriteRequest {
    fn clear(&mut self) {
        self.file_name.clear();
        self.block.clear();
        self.is_end = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NextWriteRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NextWriteRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NextWriteResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NextWriteResponse {
    fn default() -> &'a NextWriteResponse {
        <NextWriteResponse as ::protobuf::Message>::default_instance()
    }
}

impl NextWriteResponse {
    pub fn new() -> NextWriteResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for NextWriteResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NextWriteResponse {
        NextWriteResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<NextWriteResponse>(
                    "NextWriteResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NextWriteResponse {
        static mut instance: ::protobuf::lazy::Lazy<NextWriteResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NextWriteResponse,
        };
        unsafe {
            instance.get(NextWriteResponse::new)
        }
    }
}

impl ::protobuf::Clear for NextWriteResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NextWriteResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NextWriteResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0byadfs.proto\"\"\n\x0cHelloRequest\x12\x12\n\x04name\x18\x01\x20\
    \x01(\tR\x04name\"#\n\rHelloResponse\x12\x12\n\x04name\x18\x01\x20\x01(\
    \tR\x04name\",\n\rGetDirRequest\x12\x1b\n\tfile_path\x18\x01\x20\x01(\tR\
    \x08filePath\"1\n\x0eGetDirResponse\x12\x1f\n\x0bcurrent_dir\x18\x01\x20\
    \x01(\tR\ncurrentDir\"-\n\x10ChangeDirRequest\x12\x19\n\x08dir_path\x18\
    \x01\x20\x01(\tR\x07dirPath\"2\n\x11ChangeDirResponse\x12\x1d\n\nis_succ\
    ess\x18\x01\x20\x01(\x05R\tisSuccess\"\x12\n\x10FileCountRequest\"2\n\
    \x11FileCountResponse\x12\x1d\n\nfile_count\x18\x01\x20\x01(\x05R\tfileC\
    ount\"\r\n\x0bListRequest\")\n\x0cListResponse\x12\x19\n\x08list_dir\x18\
    \x01\x20\x01(\tR\x07listDir\"4\n\x15OpenFiletoReadRequest\x12\x1b\n\tfil\
    e_path\x18\x01\x20\x01(\tR\x08filePath\"7\n\x16OpenFiletoReadResponse\
    \x12\x1d\n\nis_success\x18\x01\x20\x01(\x05R\tisSuccess\".\n\x0fNextRead\
    Request\x12\x1b\n\tfile_name\x18\x01\x20\x01(\tR\x08fileName\"\\\n\x10Ne\
    xtReadResponse\x12\x1b\n\tfile_name\x18\x01\x20\x01(\tR\x08fileName\x12\
    \x14\n\x05block\x18\x02\x20\x01(\tR\x05block\x12\x15\n\x06is_end\x18\x03\
    \x20\x01(\x05R\x05isEnd\"/\n\x10CloseFileRequest\x12\x1b\n\tfile_path\
    \x18\x01\x20\x01(\tR\x08filePath\"2\n\x11CloseFileResponse\x12\x1d\n\nis\
    _success\x18\x01\x20\x01(\x05R\tisSuccess\"5\n\x16OpenFiletoWriteRequest\
    \x12\x1b\n\tfile_path\x18\x01\x20\x01(\tR\x08filePath\"8\n\x17OpenFileto\
    WriteResopnse\x12\x1d\n\nis_success\x18\x01\x20\x01(\x05R\tisSuccess\"\\\
    \n\x10NextWriteRequest\x12\x1b\n\tfile_name\x18\x01\x20\x01(\tR\x08fileN\
    ame\x12\x14\n\x05block\x18\x02\x20\x01(\tR\x05block\x12\x15\n\x06is_end\
    \x18\x03\x20\x01(\x05R\x05isEnd\"\x13\n\x11NextWriteResponse2\x90\x04\n\
    \x0cYadfsService\x12&\n\x05Hello\x12\r.HelloRequest\x1a\x0e.HelloRespons\
    e\x12)\n\x06Getdir\x12\x0e.GetDirRequest\x1a\x0f.GetDirResponse\x122\n\t\
    ChangeDir\x12\x11.ChangeDirRequest\x1a\x12.ChangeDirResponse\x122\n\tFil\
    eCount\x12\x11.FileCountRequest\x1a\x12.FileCountResponse\x12#\n\x04List\
    \x12\x0c.ListRequest\x1a\r.ListResponse\x12A\n\x0eOpenFileToRead\x12\x16\
    .OpenFiletoReadRequest\x1a\x17.OpenFiletoReadResponse\x12/\n\x08NextRead\
    \x12\x10.NextReadRequest\x1a\x11.NextReadResponse\x122\n\tCloseFile\x12\
    \x11.CloseFileRequest\x1a\x12.CloseFileResponse\x12D\n\x0fOpenFileToWrit\
    e\x12\x17.OpenFiletoWriteRequest\x1a\x18.OpenFiletoWriteResopnse\x122\n\
    \tNextWrite\x12\x11.NextWriteRequest\x1a\x12.NextWriteResponseJ\xa1\x11\
    \n\x06\x12\x04\0\01\x01\n\x08\n\x01\x0c\x12\x03\0\0\x12\n\t\n\x02\x04\0\
    \x12\x03\x02\0)\n\n\n\x03\x04\0\x01\x12\x03\x02\x08\x14\n\x0b\n\x04\x04\
    \0\x02\0\x12\x03\x02\x17'\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03\x02\x17\
    \x1d\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03\x02\x1e\"\n\x0c\n\x05\x04\0\x02\
    \0\x03\x12\x03\x02%&\n\t\n\x02\x04\x01\x12\x03\x03\0*\n\n\n\x03\x04\x01\
    \x01\x12\x03\x03\x08\x15\n\x0b\n\x04\x04\x01\x02\0\x12\x03\x03\x18(\n\
    \x0c\n\x05\x04\x01\x02\0\x05\x12\x03\x03\x18\x1e\n\x0c\n\x05\x04\x01\x02\
    \0\x01\x12\x03\x03\x1f#\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03\x03&'\n\t\
    \n\x02\x04\x02\x12\x03\x05\0/\n\n\n\x03\x04\x02\x01\x12\x03\x05\x08\x15\
    \n\x0b\n\x04\x04\x02\x02\0\x12\x03\x05\x18-\n\x0c\n\x05\x04\x02\x02\0\
    \x05\x12\x03\x05\x18\x1e\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03\x05\x1f(\
    \n\x0c\n\x05\x04\x02\x02\0\x03\x12\x03\x05+,\n\t\n\x02\x04\x03\x12\x03\
    \x06\02\n\n\n\x03\x04\x03\x01\x12\x03\x06\x08\x16\n\x0b\n\x04\x04\x03\
    \x02\0\x12\x03\x06\x190\n\x0c\n\x05\x04\x03\x02\0\x05\x12\x03\x06\x19\
    \x1f\n\x0c\n\x05\x04\x03\x02\0\x01\x12\x03\x06\x20+\n\x0c\n\x05\x04\x03\
    \x02\0\x03\x12\x03\x06./\n\t\n\x02\x04\x04\x12\x03\x08\01\n\n\n\x03\x04\
    \x04\x01\x12\x03\x08\x08\x18\n\x0b\n\x04\x04\x04\x02\0\x12\x03\x08\x1b/\
    \n\x0c\n\x05\x04\x04\x02\0\x05\x12\x03\x08\x1b!\n\x0c\n\x05\x04\x04\x02\
    \0\x01\x12\x03\x08\"*\n\x0c\n\x05\x04\x04\x02\0\x03\x12\x03\x08-.\n\t\n\
    \x02\x04\x05\x12\x03\t\03\n\n\n\x03\x04\x05\x01\x12\x03\t\x08\x19\n\x0b\
    \n\x04\x04\x05\x02\0\x12\x03\t\x1c1\n\x0c\n\x05\x04\x05\x02\0\x05\x12\
    \x03\t\x1c!\n\x0c\n\x05\x04\x05\x02\0\x01\x12\x03\t\",\n\x0c\n\x05\x04\
    \x05\x02\0\x03\x12\x03\t/0\n\t\n\x02\x04\x06\x12\x03\x0b\0\x1b\n\n\n\x03\
    \x04\x06\x01\x12\x03\x0b\x08\x18\n\t\n\x02\x04\x07\x12\x03\x0c\03\n\n\n\
    \x03\x04\x07\x01\x12\x03\x0c\x08\x19\n\x0b\n\x04\x04\x07\x02\0\x12\x03\
    \x0c\x1c1\n\x0c\n\x05\x04\x07\x02\0\x05\x12\x03\x0c\x1c!\n\x0c\n\x05\x04\
    \x07\x02\0\x01\x12\x03\x0c\",\n\x0c\n\x05\x04\x07\x02\0\x03\x12\x03\x0c/\
    0\n\t\n\x02\x04\x08\x12\x03\x0e\0\x16\n\n\n\x03\x04\x08\x01\x12\x03\x0e\
    \x08\x13\n\t\n\x02\x04\t\x12\x03\x0f\0-\n\n\n\x03\x04\t\x01\x12\x03\x0f\
    \x08\x14\n\x0b\n\x04\x04\t\x02\0\x12\x03\x0f\x17+\n\x0c\n\x05\x04\t\x02\
    \0\x05\x12\x03\x0f\x17\x1d\n\x0c\n\x05\x04\t\x02\0\x01\x12\x03\x0f\x1e&\
    \n\x0c\n\x05\x04\t\x02\0\x03\x12\x03\x0f)*\n\t\n\x02\x04\n\x12\x03\x11\0\
    7\n\n\n\x03\x04\n\x01\x12\x03\x11\x08\x1d\n\x0b\n\x04\x04\n\x02\0\x12\
    \x03\x11\x205\n\x0c\n\x05\x04\n\x02\0\x05\x12\x03\x11\x20&\n\x0c\n\x05\
    \x04\n\x02\0\x01\x12\x03\x11'0\n\x0c\n\x05\x04\n\x02\0\x03\x12\x03\x1134\
    \n\t\n\x02\x04\x0b\x12\x03\x12\08\n\n\n\x03\x04\x0b\x01\x12\x03\x12\x08\
    \x1e\n\x0b\n\x04\x04\x0b\x02\0\x12\x03\x12!6\n\x0c\n\x05\x04\x0b\x02\0\
    \x05\x12\x03\x12!&\n\x0c\n\x05\x04\x0b\x02\0\x01\x12\x03\x12'1\n\x0c\n\
    \x05\x04\x0b\x02\0\x03\x12\x03\x1245\n\t\n\x02\x04\x0c\x12\x03\x13\01\n\
    \n\n\x03\x04\x0c\x01\x12\x03\x13\x08\x17\n\x0b\n\x04\x04\x0c\x02\0\x12\
    \x03\x13\x1a/\n\x0c\n\x05\x04\x0c\x02\0\x05\x12\x03\x13\x1a\x20\n\x0c\n\
    \x05\x04\x0c\x02\0\x01\x12\x03\x13!*\n\x0c\n\x05\x04\x0c\x02\0\x03\x12\
    \x03\x13-.\n\n\n\x02\x04\r\x12\x04\x14\0\x18\x01\n\n\n\x03\x04\r\x01\x12\
    \x03\x14\x08\x18\n\x0b\n\x04\x04\r\x02\0\x12\x03\x15\x02\x17\n\x0c\n\x05\
    \x04\r\x02\0\x05\x12\x03\x15\x02\x08\n\x0c\n\x05\x04\r\x02\0\x01\x12\x03\
    \x15\t\x12\n\x0c\n\x05\x04\r\x02\0\x03\x12\x03\x15\x15\x16\n\x0b\n\x04\
    \x04\r\x02\x01\x12\x03\x16\x02\x13\n\x0c\n\x05\x04\r\x02\x01\x05\x12\x03\
    \x16\x02\x08\n\x0c\n\x05\x04\r\x02\x01\x01\x12\x03\x16\t\x0e\n\x0c\n\x05\
    \x04\r\x02\x01\x03\x12\x03\x16\x11\x12\n\x0b\n\x04\x04\r\x02\x02\x12\x03\
    \x17\x02\x13\n\x0c\n\x05\x04\r\x02\x02\x05\x12\x03\x17\x02\x07\n\x0c\n\
    \x05\x04\r\x02\x02\x01\x12\x03\x17\x08\x0e\n\x0c\n\x05\x04\r\x02\x02\x03\
    \x12\x03\x17\x11\x12\n\t\n\x02\x04\x0e\x12\x03\x1a\02\n\n\n\x03\x04\x0e\
    \x01\x12\x03\x1a\x08\x18\n\x0b\n\x04\x04\x0e\x02\0\x12\x03\x1a\x1b0\n\
    \x0c\n\x05\x04\x0e\x02\0\x05\x12\x03\x1a\x1b!\n\x0c\n\x05\x04\x0e\x02\0\
    \x01\x12\x03\x1a\"+\n\x0c\n\x05\x04\x0e\x02\0\x03\x12\x03\x1a./\n\t\n\
    \x02\x04\x0f\x12\x03\x1b\03\n\n\n\x03\x04\x0f\x01\x12\x03\x1b\x08\x19\n\
    \x0b\n\x04\x04\x0f\x02\0\x12\x03\x1b\x1c1\n\x0c\n\x05\x04\x0f\x02\0\x05\
    \x12\x03\x1b\x1c!\n\x0c\n\x05\x04\x0f\x02\0\x01\x12\x03\x1b\",\n\x0c\n\
    \x05\x04\x0f\x02\0\x03\x12\x03\x1b/0\n\t\n\x02\x04\x10\x12\x03\x1d\08\n\
    \n\n\x03\x04\x10\x01\x12\x03\x1d\x08\x1e\n\x0b\n\x04\x04\x10\x02\0\x12\
    \x03\x1d!6\n\x0c\n\x05\x04\x10\x02\0\x05\x12\x03\x1d!'\n\x0c\n\x05\x04\
    \x10\x02\0\x01\x12\x03\x1d(1\n\x0c\n\x05\x04\x10\x02\0\x03\x12\x03\x1d45\
    \n\t\n\x02\x04\x11\x12\x03\x1e\09\n\n\n\x03\x04\x11\x01\x12\x03\x1e\x08\
    \x1f\n\x0b\n\x04\x04\x11\x02\0\x12\x03\x1e\"7\n\x0c\n\x05\x04\x11\x02\0\
    \x05\x12\x03\x1e\"'\n\x0c\n\x05\x04\x11\x02\0\x01\x12\x03\x1e(2\n\x0c\n\
    \x05\x04\x11\x02\0\x03\x12\x03\x1e56\n\n\n\x02\x04\x12\x12\x04\x1f\0#\
    \x01\n\n\n\x03\x04\x12\x01\x12\x03\x1f\x08\x18\n\x0b\n\x04\x04\x12\x02\0\
    \x12\x03\x20\x02\x17\n\x0c\n\x05\x04\x12\x02\0\x05\x12\x03\x20\x02\x08\n\
    \x0c\n\x05\x04\x12\x02\0\x01\x12\x03\x20\t\x12\n\x0c\n\x05\x04\x12\x02\0\
    \x03\x12\x03\x20\x15\x16\n\x0b\n\x04\x04\x12\x02\x01\x12\x03!\x02\x13\n\
    \x0c\n\x05\x04\x12\x02\x01\x05\x12\x03!\x02\x08\n\x0c\n\x05\x04\x12\x02\
    \x01\x01\x12\x03!\t\x0e\n\x0c\n\x05\x04\x12\x02\x01\x03\x12\x03!\x11\x12\
    \n\x0b\n\x04\x04\x12\x02\x02\x12\x03\"\x02\x13\n\x0c\n\x05\x04\x12\x02\
    \x02\x05\x12\x03\"\x02\x07\n\x0c\n\x05\x04\x12\x02\x02\x01\x12\x03\"\x08\
    \x0e\n\x0c\n\x05\x04\x12\x02\x02\x03\x12\x03\"\x11\x12\n\t\n\x02\x04\x13\
    \x12\x03$\0\x1c\n\n\n\x03\x04\x13\x01\x12\x03$\x08\x19\n\n\n\x02\x06\0\
    \x12\x04&\01\x01\n\n\n\x03\x06\0\x01\x12\x03&\x08\x14\n\x0b\n\x04\x06\0\
    \x02\0\x12\x03'\x022\n\x0c\n\x05\x06\0\x02\0\x01\x12\x03'\x06\x0b\n\x0c\
    \n\x05\x06\0\x02\0\x02\x12\x03'\x0c\x18\n\x0c\n\x05\x06\0\x02\0\x03\x12\
    \x03'#0\n\x0b\n\x04\x06\0\x02\x01\x12\x03(\x025\n\x0c\n\x05\x06\0\x02\
    \x01\x01\x12\x03(\x06\x0c\n\x0c\n\x05\x06\0\x02\x01\x02\x12\x03(\r\x1a\n\
    \x0c\n\x05\x06\0\x02\x01\x03\x12\x03(%3\n\x0b\n\x04\x06\0\x02\x02\x12\
    \x03)\x02>\n\x0c\n\x05\x06\0\x02\x02\x01\x12\x03)\x06\x0f\n\x0c\n\x05\
    \x06\0\x02\x02\x02\x12\x03)\x10\x20\n\x0c\n\x05\x06\0\x02\x02\x03\x12\
    \x03)+<\n\x0b\n\x04\x06\0\x02\x03\x12\x03*\x02>\n\x0c\n\x05\x06\0\x02\
    \x03\x01\x12\x03*\x06\x0f\n\x0c\n\x05\x06\0\x02\x03\x02\x12\x03*\x10\x20\
    \n\x0c\n\x05\x06\0\x02\x03\x03\x12\x03*+<\n\x0b\n\x04\x06\0\x02\x04\x12\
    \x03+\x02/\n\x0c\n\x05\x06\0\x02\x04\x01\x12\x03+\x06\n\n\x0c\n\x05\x06\
    \0\x02\x04\x02\x12\x03+\x0b\x16\n\x0c\n\x05\x06\0\x02\x04\x03\x12\x03+!-\
    \n\x0b\n\x04\x06\0\x02\x05\x12\x03,\x02M\n\x0c\n\x05\x06\0\x02\x05\x01\
    \x12\x03,\x06\x14\n\x0c\n\x05\x06\0\x02\x05\x02\x12\x03,\x15*\n\x0c\n\
    \x05\x06\0\x02\x05\x03\x12\x03,5K\n\x0b\n\x04\x06\0\x02\x06\x12\x03-\x02\
    ;\n\x0c\n\x05\x06\0\x02\x06\x01\x12\x03-\x06\x0e\n\x0c\n\x05\x06\0\x02\
    \x06\x02\x12\x03-\x0f\x1e\n\x0c\n\x05\x06\0\x02\x06\x03\x12\x03-)9\n\x0b\
    \n\x04\x06\0\x02\x07\x12\x03.\x02>\n\x0c\n\x05\x06\0\x02\x07\x01\x12\x03\
    .\x06\x0f\n\x0c\n\x05\x06\0\x02\x07\x02\x12\x03.\x10\x20\n\x0c\n\x05\x06\
    \0\x02\x07\x03\x12\x03.+<\n\x0b\n\x04\x06\0\x02\x08\x12\x03/\x02P\n\x0c\
    \n\x05\x06\0\x02\x08\x01\x12\x03/\x06\x15\n\x0c\n\x05\x06\0\x02\x08\x02\
    \x12\x03/\x16,\n\x0c\n\x05\x06\0\x02\x08\x03\x12\x03/7N\n\x0b\n\x04\x06\
    \0\x02\t\x12\x030\x02>\n\x0c\n\x05\x06\0\x02\t\x01\x12\x030\x06\x0f\n\
    \x0c\n\x05\x06\0\x02\t\x02\x12\x030\x10\x20\n\x0c\n\x05\x06\0\x02\t\x03\
    \x12\x030+<b\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
